{"name":"GrEP","tagline":"Dual-Core Processor's OPLS15 Project.","body":"##Authors\r\nOur team, Dual-Core Processors, consists of Michael Forsyth, Nicholas Forsyth, and Emily Seto.\r\n\r\n##Overview\r\nOur project is called the Graph-ical Emulation Program (also known as GrEP). In our earlier discussions, we began thinking about how there needs to be a simpler way for individuals with non-technical backgrounds to utilize the capabilities of plotting mathematical functions. Our software will provide this solution.\r\n\r\n##Screenshots\r\n![screenshot new gui](gui1.png)\r\n\r\n\r\nThis is how the **gui frame** first looks when the software starts up.\r\n\r\n![screenshot filled gui](gui.png)\r\n\r\n\r\nThis is how the same window looks after inputting lower and upper bounds for the x-, y-coordinates on a Cartesian plane. Note that this particular part is still in development. For now, all function inputs must be written in the form of a **lambda**, as shown above.\r\n\r\n![screenshot new plot](plot.png)\r\n\r\n\r\nThis is the new plot created with the given user input.\r\n\r\n\r\n##Concepts Demonstrated\r\nIdentify the OPL concepts demonstrated in your project. Be brief. A simple list and example is sufficient. \r\n* **Data abstraction** is used to provide access to the elements of the RSS feed.\r\n* The objects in the OpenGL world are represented with **recursive data structures.**\r\n* **Symbolic language processing techniques** are used in the parser.\r\n\r\n\r\n##External Technology and Libraries\r\nFor this project, we used the following libraries:\r\n* **racket/gui/base** (http://docs.racket-lang.org/gui/)\r\n* **plot** (http://docs.racket-lang.org/plot/)\r\n\r\nRacket's **racket/gui** library provides the classes and procedures that allowed us to create a graphical user interface. Our team used **racket/gui** to create a new frame (a window), a horizontal panel within that frame, and used a few different widgets to attain user input (such as the button and text-field widgets). \r\n\r\n\r\nThe **plot** library allows us to produce any plot (or graph) we desire. From the user input we ascertained from **racket/gui**, our team was able to plot that information to create graphs desired by the user.\r\n\r\n##Favorite Lines of Code\r\n####Michael Forsyth (@mike01720)\r\nEach team member should identify a favorite line of code, expression, or procedure written by them, and explain what it does. Why is it your favorite? What OPL philosophy does it embody?\r\nRemember code looks something like this:\r\n```scheme\r\n(map (lambda (x) (foldr compose functions)) data)\r\n```\r\n\r\n\r\n####Nicholas Forsyth (@nick01720)\r\nThis expression reads in a regular expression and elegantly matches it against a pre-existing hashmap....\r\n```scheme\r\n(let* ((expr (convert-to-regexp (read-line my-in-port)))\r\n             (matches (flatten\r\n                       (hash-map *words*\r\n                                 (lambda (key value)\r\n                                   (if (regexp-match expr key) key '()))))))\r\n  matches)\r\n```\r\n\r\n\r\n####Emily Seto (@svnaptic)\r\nWrite something here.\r\n\r\n\r\n##Additional Remarks\r\nAnything else you want to say in your report. Can rename or remove this section.\r\n\r\n#How to Download and Run\r\nYou may want to link to your latest release for easy downloading by people (such as Mark).\r\n\r\nInclude what file to run, what to do with that file, how to interact with the app when its running, etc. \r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}